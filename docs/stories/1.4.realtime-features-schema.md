# Story 1.4: Real-time Features Schema Implementation

## Status
Ready for Development

## Story

**As a** CSN platform user,
**I want** my viewing progress to sync across devices and see live viewer counts during streams,
**so that** I can seamlessly continue watching on any device and feel the excitement of watching live sports with a community.

## Acceptance Criteria

1. **Watch Progress Table**: Implement `user_watch_progress` for "Continue Watching" feature:
   - Track playback position per user per content
   - Store duration and completion percentage
   - Timestamp last watched for recency sorting
   - Support device type tracking
   - Mark completed content (>90% watched)
   - Enable cross-device sync via Convex real-time subscriptions

2. **Live Stream Sessions Table**: Implement `live_stream_sessions` for real-time viewer tracking:
   - Track active viewers per live game
   - Support anonymous and authenticated users
   - Implement heartbeat pattern (30-second updates)
   - Track join time and last activity
   - Record device type and stream quality
   - Enable automatic session cleanup for stale connections

3. **Live Chat Messages Table**: Implement `live_chat_messages` for real-time game chat:
   - Store chat messages per game
   - Denormalize user info for fast display
   - Support moderation statuses (active/hidden/deleted)
   - Order by timestamp for chronological display
   - Enable real-time message delivery via subscriptions
   - Support admin moderation actions

4. **Real-time Query Optimization**: Add indexes for performance:
   - Index by user for personal data queries
   - Index by game for live stream queries
   - Index by timestamp for sorting
   - Index by status for filtering
   - Document expected query patterns

5. **Heartbeat & Cleanup Strategy**: Design session management:
   - Document heartbeat update pattern (30s interval)
   - Define stale session threshold (2 minutes)
   - Plan cleanup job for inactive sessions
   - Design real-time viewer count aggregation

## Tasks / Subtasks

- [ ] **Design Watch Progress Table** (AC: 1)
  - [ ] Define `user_watch_progress` table schema
  - [ ] Add user_id, content_id, position fields
  - [ ] Add completion percentage calculation
  - [ ] Add device_type tracking
  - [ ] Create indexes: by_user, by_user_content, by_last_watched
  - [ ] Document "Continue Watching" query pattern

- [ ] **Design Live Stream Sessions Table** (AC: 2)
  - [ ] Define `live_stream_sessions` table schema
  - [ ] Add game_id, user_id (optional), session_id
  - [ ] Add heartbeat timestamp field
  - [ ] Add active boolean flag
  - [ ] Add device and quality tracking
  - [ ] Create indexes: by_game_active, by_session, by_heartbeat
  - [ ] Document viewer count query pattern

- [ ] **Design Live Chat Messages Table** (AC: 3)
  - [ ] Define `live_chat_messages` table schema
  - [ ] Add game_id, user_id, message fields
  - [ ] Add denormalized user_name and user_avatar
  - [ ] Add moderation status field
  - [ ] Create indexes: by_game (with timestamp), by_user
  - [ ] Document chat pagination pattern

- [ ] **Add Performance Indexes** (AC: 4)
  - [ ] Review all three tables for index needs
  - [ ] Add compound indexes for common queries
  - [ ] Document expected query times
  - [ ] Plan for index maintenance

- [ ] **Document Real-time Patterns** (AC: 5)
  - [ ] Write heartbeat implementation guide
  - [ ] Define stale session cleanup logic
  - [ ] Document real-time subscription patterns
  - [ ] Create viewer count aggregation example
  - [ ] Write chat moderation workflow

- [ ] **Schema Validation** (AC: All)
  - [ ] Run TypeScript type checking
  - [ ] Deploy to dev environment
  - [ ] Test with sample real-time data
  - [ ] Verify subscription updates work
  - [ ] Performance test concurrent users

## Dev Notes

### Technology Stack Context
[Source: docs/TECHNICAL_OVERVIEW.md, docs/CONVEX_ARCHITECTURE.md]
- **Real-time Engine**: Convex subscriptions for automatic UI updates
- **Pattern**: Subscribe via `useQuery()`, updates push automatically
- **Performance Target**: < 500ms real-time update latency
- **Concurrency**: Support 1000+ concurrent live stream viewers

### Convex Real-time Architecture
[Source: docs/CONVEX_ARCHITECTURE.md]

**Real-time Subscription Pattern:**
```typescript
// Frontend automatically receives updates
const watchProgress = useQuery(api.watchProgress.getContinueWatching, {
  userId: currentUser.id
});

// When backend mutates data, UI updates instantly
const updateProgress = useMutation(api.watchProgress.updateProgress);
```

**Key Principle**: Convex handles operational data with real-time reactivity

### Winston's Real-time Schema Design

#### Table 1: `user_watch_progress`
```typescript
user_watch_progress: defineTable({
  user_id: v.id("users"),
  content_id: v.id("content"),

  // Playback state
  position_seconds: v.number(),
  duration_seconds: v.number(),
  completion_percentage: v.number(),  // 0-100

  // Real-time updates
  last_watched_at: v.number(),
  device_type: v.optional(v.string()),  // "desktop", "mobile", "tablet"

  // Status
  completed: v.boolean(),  // true if completion_percentage >= 90
})
  .index("by_user", ["user_id"])
  .index("by_user_content", ["user_id", "content_id"])
  .index("by_last_watched", ["user_id", "last_watched_at"]),
```

**Design Rationale:**
- ✅ Powers "Continue Watching" carousel
- ✅ Syncs across devices via real-time subscriptions
- ✅ Completion tracking for analytics
- ✅ Recency sorting via last_watched_at

**Query Patterns:**
```typescript
// Get Continue Watching (most recent unfinished content)
.query("user_watch_progress")
  .withIndex("by_last_watched", q =>
    q.eq("user_id", userId)
  )
  .filter(q => !q.eq("completed", true))
  .order("desc")
  .take(10);

// Get progress for specific content (resume playback)
.query("user_watch_progress")
  .withIndex("by_user_content", q =>
    q.eq("user_id", userId).eq("content_id", contentId)
  )
  .first();
```

#### Table 2: `live_stream_sessions`
```typescript
live_stream_sessions: defineTable({
  game_id: v.id("games"),
  user_id: v.optional(v.id("users")),  // Anonymous viewers allowed
  session_id: v.string(),  // UUID for tracking

  // Real-time presence
  joined_at: v.number(),
  last_heartbeat: v.number(),  // Updated every 30s
  active: v.boolean(),

  // Device info
  device_type: v.string(),  // "desktop", "mobile", "tablet"
  quality: v.optional(v.string()),  // "720p", "1080p"
})
  .index("by_game_active", ["game_id", "active"])
  .index("by_session", ["session_id"])
  .index("by_heartbeat", ["last_heartbeat"]),
```

**Design Rationale:**
- ✅ Tracks real-time viewer count
- ✅ Supports both logged-in and anonymous users
- ✅ Heartbeat pattern prevents stale sessions
- ✅ Device/quality tracking for analytics

**Heartbeat Pattern:**
```typescript
// Client sends heartbeat every 30 seconds
setInterval(async () => {
  await updateHeartbeat({ sessionId, gameId });
}, 30000);

// Server marks sessions as inactive if no heartbeat > 2 minutes
// Cleanup job runs every minute
```

**Viewer Count Query:**
```typescript
// Get active viewer count
const activeSessions = await ctx.db
  .query("live_stream_sessions")
  .withIndex("by_game_active", q =>
    q.eq("game_id", gameId).eq("active", true)
  )
  .collect();

return { viewerCount: activeSessions.length };
```

#### Table 3: `live_chat_messages`
```typescript
live_chat_messages: defineTable({
  game_id: v.id("games"),
  user_id: v.id("users"),

  // Message
  message: v.string(),

  // User info (denormalized for speed)
  user_name: v.string(),
  user_avatar: v.optional(v.string()),

  // Moderation
  status: v.union(
    v.literal("active"),
    v.literal("hidden"),
    v.literal("deleted")
  ),

  // Timestamp
  created_at: v.number(),
})
  .index("by_game", ["game_id", "created_at"])
  .index("by_user", ["user_id"]),
```

**Design Rationale:**
- ✅ Denormalized user info for instant display (no joins)
- ✅ Moderation support for admin controls
- ✅ Real-time message delivery via subscriptions
- ✅ Timestamp ordering for chronological chat

**Chat Query Pattern:**
```typescript
// Get recent chat messages (real-time subscription)
const messages = useQuery(api.chat.getMessages, {
  gameId: currentGame.id,
  limit: 50
});

// Auto-updates as new messages arrive
```

### Real-time Update Flow

```
┌─────────────────────────────────────────────────┐
│         USER DEVICE A (Desktop)                 │
│                                                 │
│  Playing video at 5:23                          │
│         │                                       │
│         ▼                                       │
│  updateWatchProgress({ position: 323 })         │
│                                                 │
└─────────────────┬───────────────────────────────┘
                  │
                  │ Mutation
                  │
                  ▼
      ┌───────────────────────────┐
      │   CONVEX BACKEND          │
      │                           │
      │  Mutation updates DB      │
      │  position_seconds = 323   │
      │                           │
      └───────────┬───────────────┘
                  │
                  │ Subscription pushes update
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│         USER DEVICE B (Mobile)                  │
│                                                 │
│  Continue Watching UI updates automatically     │
│  Shows: "Resume at 5:23"                        │
│                                                 │
└─────────────────────────────────────────────────┘
```

### Performance Considerations

**Expected Query Patterns & Times:**
- Get Continue Watching: < 50ms (indexed by user + timestamp)
- Get viewer count: < 100ms (indexed by game + active)
- Get chat messages: < 50ms (indexed by game + created_at)
- Update watch progress: < 100ms (upsert operation)
- Heartbeat update: < 50ms (simple field update)

**Real-time Update Latency:**
- Mutation → Subscription: < 500ms target
- Actual Convex performance: typically < 200ms

**Scalability Targets:**
- 10,000+ users with watch progress
- 1,000+ concurrent live stream viewers per game
- 100+ messages per minute in chat
- 30-second heartbeat from all active sessions

### Session Cleanup Strategy

**Stale Session Detection:**
```typescript
// Cleanup job runs every minute
const twoMinutesAgo = Date.now() - (2 * 60 * 1000);

const staleSessions = await ctx.db
  .query("live_stream_sessions")
  .withIndex("by_heartbeat", q =>
    q.lt("last_heartbeat", twoMinutesAgo)
  )
  .collect();

// Mark as inactive
for (const session of staleSessions) {
  await ctx.db.patch(session._id, { active: false });
}
```

**Benefits:**
- Accurate viewer counts
- No memory leaks from abandoned sessions
- Clean data for analytics

### Chat Moderation Workflow

**Moderation Actions:**
1. Admin sees chat message
2. Clicks "Hide" or "Delete"
3. Frontend calls moderation mutation
4. Mutation updates message status
5. Real-time subscription pushes update
6. Message disappears/grays out for all users

**Implementation:**
```typescript
export const moderateMessage = mutation({
  args: {
    messageId: v.id("live_chat_messages"),
    status: v.union(v.literal("hidden"), v.literal("deleted"))
  },
  handler: async (ctx, args) => {
    await requireAdminAuth(ctx, "write:chat");
    await ctx.db.patch(args.messageId, {
      status: args.status
    });
  }
});
```

### Dependencies

**Prerequisite Work:**
- ✅ Story 1.3 (Core Schema) - Should complete first for consistency
- ✅ Convex real-time subscriptions configured
- ✅ Frontend `useQuery` hooks set up

**Blocks:**
- Story 1.6 (CRUD Functions) - Can start in parallel with Story 1.5

**Can Run in Parallel With:**
- Story 1.5 (Analytics Integration) - No schema conflicts

### Testing Requirements

#### Real-time Functionality Tests
- Watch progress updates across multiple browser tabs
- Viewer count increases/decreases in real-time
- Chat messages appear instantly for all viewers
- Heartbeat keeps sessions active
- Stale sessions marked inactive after 2 minutes

#### Performance Tests
- 100 concurrent users updating watch progress
- 1000 active live stream sessions
- 50 chat messages per second
- Measure subscription update latency

#### Edge Cases
- User opens video on 3 devices simultaneously (last write wins)
- Chat message sent while user is being moderated
- Heartbeat fails (network issue) - session times out correctly
- Viewer count during connection instability

### Known Limitations & Future Work

**Current Limitations:**
- Simple last-write-wins for watch progress (no conflict resolution)
- No chat message editing (only hide/delete)
- No chat rate limiting (future story)
- Basic heartbeat pattern (could optimize with WebSockets)

**Future Enhancements:**
- Add chat reactions/emojis
- Add chat reply threading
- Add user blocking/muting
- Add watch party features (synchronized playback)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be added here after implementation*
