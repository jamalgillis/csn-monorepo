# Story 1.6: CRUD Functions Implementation for All New Tables

## Status
Ready for Development

## Story

**As a** CSN platform developer,
**I want** complete, minimal-code CRUD functions for all new schema tables,
**so that** the frontend can efficiently create, read, update, and delete data with proper authorization, real-time updates, and audit logging.

## Acceptance Criteria

1. **Media Assets CRUD**: Implement full lifecycle management:
   - `createMediaAsset` - Track new upload with metadata
   - `getMediaAsset` - Fetch single asset by ID
   - `getMediaAssets` - List assets with filtering (by uploader, type, status, folder)
   - `updateMediaAsset` - Edit title, description, tags, folder
   - `deleteMediaAsset` - Soft delete (mark as archived)
   - `searchMediaAssets` - Full-text search by title
   - All mutations require admin authorization

2. **Enhanced Content CRUD**: Add authorship tracking:
   - `createContent` - Enhanced with created_by, workflow_status
   - `updateContent` - Enhanced with updated_by, audit logging
   - `publishContent` - Workflow transition (draft → published)
   - `getContentAuditLog` - Fetch edit history for content
   - All mutations create audit log entries
   - Existing content queries remain unchanged

3. **Watch Progress CRUD**: Real-time sync across devices:
   - `updateWatchProgress` - Upsert progress (create or update)
   - `getWatchProgress` - Get progress for specific content
   - `getContinueWatching` - Get recent unfinished content
   - `markAsComplete` - Mark content as fully watched
   - Real-time subscription updates
   - Last-write-wins conflict resolution

4. **Live Stream Sessions CRUD**: Viewer tracking:
   - `createLiveSession` - Join live stream
   - `updateHeartbeat` - Keep session alive (30s interval)
   - `endLiveSession` - Leave stream
   - `getLiveViewerCount` - Get active viewer count
   - `cleanupStaleSessions` - Remove inactive sessions (cron job)
   - Real-time viewer count updates

5. **Live Chat CRUD**: Real-time messaging:
   - `sendChatMessage` - Post new message
   - `getChatMessages` - Get recent messages with pagination
   - `moderateChatMessage` - Admin hide/delete message
   - Real-time message subscriptions
   - Denormalized user info for performance

6. **Authorization & Security**: Protect all mutations:
   - Use `requireAdminAuth()` for admin operations
   - User-scoped queries (users only see their own data)
   - Admin queries see all data
   - Input validation on all mutations
   - SQL injection prevention (Convex handles)

7. **Error Handling**: Robust error management:
   - Throw descriptive errors
   - Return null for not-found (queries)
   - Validate required fields
   - Handle duplicate entries gracefully
   - Log errors for debugging

## Tasks / Subtasks

- [ ] **Media Assets CRUD** (AC: 1)
  - [ ] Create `convex/mediaAssets.ts` file
  - [ ] Implement `createMediaAsset` mutation
  - [ ] Implement `getMediaAsset` query
  - [ ] Implement `getMediaAssets` query with filters
  - [ ] Implement `updateMediaAsset` mutation
  - [ ] Implement `deleteMediaAsset` mutation (soft delete)
  - [ ] Implement `searchMediaAssets` query
  - [ ] Add admin auth checks to all mutations
  - [ ] Test all CRUD operations

- [ ] **Enhanced Content CRUD** (AC: 2)
  - [ ] Update `convex/content.ts`
  - [ ] Enhance `createContent` with authorship fields
  - [ ] Enhance `updateContent` with audit logging
  - [ ] Implement `publishContent` workflow mutation
  - [ ] Create `convex/contentAudit.ts`
  - [ ] Implement `createAuditEntry` mutation
  - [ ] Implement `getContentAuditLog` query
  - [ ] Test audit log creation
  - [ ] Verify existing queries unaffected

- [ ] **Watch Progress CRUD** (AC: 3)
  - [ ] Create `convex/watchProgress.ts`
  - [ ] Implement `updateWatchProgress` mutation (upsert)
  - [ ] Implement `getWatchProgress` query
  - [ ] Implement `getContinueWatching` query
  - [ ] Implement `markAsComplete` mutation
  - [ ] Test cross-device sync with real-time subscriptions
  - [ ] Test last-write-wins behavior

- [ ] **Live Stream Sessions CRUD** (AC: 4)
  - [ ] Create `convex/liveSession.ts`
  - [ ] Implement `createLiveSession` mutation
  - [ ] Implement `updateHeartbeat` mutation
  - [ ] Implement `endLiveSession` mutation
  - [ ] Implement `getLiveViewerCount` query
  - [ ] Implement `cleanupStaleSessions` (internal function for cron)
  - [ ] Test heartbeat pattern
  - [ ] Test viewer count real-time updates

- [ ] **Live Chat CRUD** (AC: 5)
  - [ ] Create `convex/liveChat.ts`
  - [ ] Implement `sendChatMessage` mutation
  - [ ] Implement `getChatMessages` query with pagination
  - [ ] Implement `moderateChatMessage` mutation
  - [ ] Add admin auth check for moderation
  - [ ] Test real-time message delivery
  - [ ] Test moderation workflow

- [ ] **Integration with Analytics** (AC: 2, 3)
  - [ ] Add analytics tracking to `publishContent`
  - [ ] Add analytics tracking to `updateWatchProgress`
  - [ ] Verify events sent to PostHog
  - [ ] Test non-blocking behavior

- [ ] **Testing & Validation** (AC: All)
  - [ ] Write unit tests for critical functions
  - [ ] Test authorization on all admin mutations
  - [ ] Test real-time subscriptions
  - [ ] Test error handling
  - [ ] Performance test with concurrent operations
  - [ ] Test audit log completeness

## Dev Notes

### Technology Stack Context
[Source: docs/CONVEX_ARCHITECTURE.md]
- **Backend Framework**: Convex queries, mutations, actions
- **Pattern**: Follow existing `convex/content.ts` style
- **Authorization**: Use `convex/admin.ts` `requireAdminAuth()` helper
- **Real-time**: Leverage Convex subscriptions automatically

### Existing CRUD Patterns
[Source: convex/content.ts]

**Query Pattern:**
```typescript
export const getContentById = query({
  args: { id: v.id("content") },
  handler: async (ctx, args) => {
    const content = await ctx.db.get(args.id);
    if (!content || content.status !== "published") {
      return null;
    }
    return content;
  }
});
```

**Mutation Pattern:**
```typescript
export const rateContent = mutation({
  args: {
    contentId: v.id("content"),
    userId: v.id("users"),
    rating: v.union(v.literal("up"), v.literal("down")),
  },
  handler: async (ctx, args) => {
    // Validation
    const content = await ctx.db.get(args.contentId);
    if (!content) {
      throw new ConvexError("Content not found");
    }

    // Check existing rating
    const existing = await ctx.db
      .query("content_ratings")
      .withIndex("by_user_content", q =>
        q.eq("user_id", args.userId).eq("content_id", args.contentId)
      )
      .first();

    if (existing) {
      // Update
      await ctx.db.patch(existing._id, {
        rating: args.rating,
        updated_at: new Date().toISOString()
      });
    } else {
      // Insert
      await ctx.db.insert("content_ratings", {
        user_id: args.userId,
        content_id: args.contentId,
        rating: args.rating,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });
    }
  }
});
```

### File Organization

```
convex/
  admin.ts              ← Existing (auth helpers)
  content.ts            ← Enhance (add authorship)
  analytics.ts          ← Story 1.5
  mediaAssets.ts        ← New (this story)
  watchProgress.ts      ← New (this story)
  liveSession.ts        ← New (this story)
  liveChat.ts           ← New (this story)
  contentAudit.ts       ← New (this story)
  schema.ts             ← Updated (Stories 1.3, 1.4)
```

### Implementation Examples

#### Media Assets CRUD
```typescript
// convex/mediaAssets.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { requireAdminAuth } from "./admin";

export const createMediaAsset = mutation({
  args: {
    title: v.string(),
    description: v.optional(v.string()),
    file_type: v.union(v.literal("video"), v.literal("image"), v.literal("audio")),
    uploadthing_key: v.string(),
    uploadthing_url: v.string(),
    duration_seconds: v.optional(v.number()),
    folder_path: v.optional(v.string()),
    tags: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    const auth = await requireAdminAuth(ctx, "write:content");

    return await ctx.db.insert("media_assets", {
      ...args,
      status: "ready",
      uploaded_by: auth.userId,
      created_at: Date.now(),
      view_count: 0,
    });
  }
});

export const getMediaAssets = query({
  args: {
    status: v.optional(v.string()),
    file_type: v.optional(v.string()),
    folder_path: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    let query = ctx.db.query("media_assets");

    if (args.status) {
      query = query.withIndex("by_status", q => q.eq("status", args.status));
    }

    const results = await query.collect();

    // Filter by other criteria (no compound indexes)
    return results.filter(asset => {
      if (args.file_type && asset.file_type !== args.file_type) return false;
      if (args.folder_path && asset.folder_path !== args.folder_path) return false;
      return true;
    });
  }
});

export const updateMediaAsset = mutation({
  args: {
    id: v.id("media_assets"),
    title: v.optional(v.string()),
    description: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    folder_path: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    await requireAdminAuth(ctx, "write:content");

    const { id, ...updates } = args;
    await ctx.db.patch(id, updates);
  }
});

export const deleteMediaAsset = mutation({
  args: { id: v.id("media_assets") },
  handler: async (ctx, args) => {
    await requireAdminAuth(ctx, "write:content");

    // Soft delete
    await ctx.db.patch(args.id, {
      status: "archived"
    });
  }
});
```

#### Watch Progress CRUD (Upsert Pattern)
```typescript
// convex/watchProgress.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const updateWatchProgress = mutation({
  args: {
    userId: v.id("users"),
    contentId: v.id("content"),
    positionSeconds: v.number(),
    durationSeconds: v.number(),
    deviceType: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Find existing progress
    const existing = await ctx.db
      .query("user_watch_progress")
      .withIndex("by_user_content", q =>
        q.eq("user_id", args.userId).eq("content_id", args.contentId)
      )
      .first();

    const completionPercentage = (args.positionSeconds / args.durationSeconds) * 100;
    const completed = completionPercentage >= 90;

    if (existing) {
      // Update
      await ctx.db.patch(existing._id, {
        position_seconds: args.positionSeconds,
        duration_seconds: args.durationSeconds,
        completion_percentage: completionPercentage,
        last_watched_at: Date.now(),
        device_type: args.deviceType,
        completed,
      });
    } else {
      // Insert
      await ctx.db.insert("user_watch_progress", {
        user_id: args.userId,
        content_id: args.contentId,
        position_seconds: args.positionSeconds,
        duration_seconds: args.durationSeconds,
        completion_percentage: completionPercentage,
        last_watched_at: Date.now(),
        device_type: args.deviceType,
        completed,
      });
    }

    // Track analytics (if completed)
    if (completed && !existing?.completed) {
      await ctx.scheduler.runAfter(0, api.analytics.trackVideoComplete, {
        videoId: args.contentId,
        watchDuration: args.durationSeconds,
      });
    }
  }
});

export const getContinueWatching = query({
  args: { userId: v.id("users") },
  handler: async (ctx, args) => {
    const progress = await ctx.db
      .query("user_watch_progress")
      .withIndex("by_last_watched", q => q.eq("user_id", args.userId))
      .filter(q => q.eq(q.field("completed"), false))
      .order("desc")
      .take(10);

    // Fetch associated content
    const contentIds = progress.map(p => p.content_id);
    const content = await Promise.all(
      contentIds.map(id => ctx.db.get(id))
    );

    return progress.map((p, i) => ({
      ...p,
      content: content[i]
    }));
  }
});
```

#### Live Session CRUD (Heartbeat Pattern)
```typescript
// convex/liveSession.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const createLiveSession = mutation({
  args: {
    gameId: v.id("games"),
    userId: v.optional(v.id("users")),
    sessionId: v.string(),
    deviceType: v.string(),
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    await ctx.db.insert("live_stream_sessions", {
      ...args,
      joined_at: now,
      last_heartbeat: now,
      active: true,
    });
  }
});

export const updateHeartbeat = mutation({
  args: { sessionId: v.string() },
  handler: async (ctx, args) => {
    const session = await ctx.db
      .query("live_stream_sessions")
      .withIndex("by_session", q => q.eq("session_id", args.sessionId))
      .first();

    if (session) {
      await ctx.db.patch(session._id, {
        last_heartbeat: Date.now(),
        active: true,
      });
    }
  }
});

export const getLiveViewerCount = query({
  args: { gameId: v.id("games") },
  handler: async (ctx, args) => {
    const activeSessions = await ctx.db
      .query("live_stream_sessions")
      .withIndex("by_game_active", q =>
        q.eq("game_id", args.gameId).eq("active", true)
      )
      .collect();

    return { viewerCount: activeSessions.length };
  }
});

// Internal function (called by cron)
export const cleanupStaleSessions = mutation({
  args: {},
  handler: async (ctx) => {
    const twoMinutesAgo = Date.now() - (2 * 60 * 1000);

    const staleSessions = await ctx.db
      .query("live_stream_sessions")
      .withIndex("by_heartbeat", q => q.lt("last_heartbeat", twoMinutesAgo))
      .collect();

    for (const session of staleSessions) {
      await ctx.db.patch(session._id, { active: false });
    }

    return { cleanedSessions: staleSessions.length };
  }
});
```

#### Enhanced Content with Audit Logging
```typescript
// convex/content.ts (enhance existing)
export const createContent = mutation({
  args: {
    type: v.string(),
    title: v.string(),
    // ... other fields
  },
  handler: async (ctx, args) => {
    const auth = await requireAdminAuth(ctx, "write:content");

    const contentId = await ctx.db.insert("content", {
      ...args,
      created_by: auth.userId,
      created_at: Date.now(),
      updated_at: Date.now(),
      workflow_status: "draft",
      status: "draft",
    });

    // Create audit log entry
    await ctx.db.insert("content_audit_log", {
      entity_type: "content",
      entity_id: contentId,
      action: "created",
      user_id: auth.userId,
      user_email: auth.email,
      user_role: auth.userRole,
      timestamp: Date.now(),
    });

    return contentId;
  }
});

export const publishContent = mutation({
  args: { contentId: v.id("content") },
  handler: async (ctx, args) => {
    const auth = await requireAdminAuth(ctx, "write:content");

    await ctx.db.patch(args.contentId, {
      workflow_status: "published",
      status: "published",
      updated_by: auth.userId,
      updated_at: Date.now(),
    });

    // Audit log
    await ctx.db.insert("content_audit_log", {
      entity_type: "content",
      entity_id: args.contentId,
      action: "published",
      user_id: auth.userId,
      user_email: auth.email,
      user_role: auth.userRole,
      timestamp: Date.now(),
    });

    // Analytics
    await ctx.scheduler.runAfter(0, api.analytics.trackAdminContentPublish, {
      contentId: args.contentId,
    });
  }
});
```

### Testing Strategy

#### Unit Tests
```typescript
// Example test structure
describe("mediaAssets", () => {
  test("createMediaAsset requires admin auth", async () => {
    // Mock non-admin user
    // Expect error
  });

  test("getMediaAssets filters by status", async () => {
    // Insert test data
    // Query with status filter
    // Verify results
  });
});
```

#### Integration Tests
- Test complete workflows (create → update → delete)
- Test real-time subscriptions deliver updates
- Test authorization on all protected operations
- Test audit log entries created correctly

#### Performance Tests
- 100 concurrent watch progress updates
- 1000 active live sessions with heartbeats
- 50 chat messages per second
- Measure query response times

### Dependencies

**Prerequisite Work:**
- ✅ Story 1.3 (Core Schema) - Must complete first
- ✅ Story 1.4 (Real-time Schema) - Must complete first
- ✅ Story 1.5 (Analytics Integration) - For integrated tracking
- ✅ Admin authorization helpers (`convex/admin.ts`)

**Blocks:**
- Future UI stories - Need these functions for frontend

### Known Limitations & Future Work

**Current Limitations:**
- No pagination on some queries (will add as needed)
- Simple last-write-wins for watch progress
- No rate limiting on chat messages
- Basic error messages (could be more descriptive)

**Future Enhancements:**
- Add cursor-based pagination
- Add optimistic concurrency control
- Add rate limiting middleware
- Add more granular permissions
- Add bulk operations

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be added here after implementation*
